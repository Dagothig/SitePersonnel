document.body.onmousemove = Move;document.body.onclick = Click;// Document variables// Canvasvar	documentElement = document.getElementById('birdie'),	context = documentElement.getContext("2d"),	width = documentElement.offsetWidth,	height = documentElement.offsetHeight,	bottomLeft = 0;// Main// sous-contrôles de mainvar controles = [];var elementsMain = document.getElementById('main').childNodes;for (var index = 0; index < elementsMain.length; index++)	if (elementsMain[index].id !== undefined)		controles[elementsMain[index].id] = elementsMain[index];// main lui-même		var	main = document.getElementById('main'),	mainHauteur = 32, 	mainVisible = true,	mainState = 'down',	birdieHauteur = 0,	focus = elementsMain[1];// Variables diversesvar	cannonHauteur = 100, loop = 1000 / 30,	cursorX = 0, cursorY = 0,	vent = 0, ventObjectif = 0;documentElement.width = width;documentElement.height = height;// Variables relatives au jeuvar Angle = 0, Kills = 0,	Objets = new Array();    // Imagesvar sprOiseau = new Image(),	sprCoup = new Image(),	sprFumee = new Image(),	sprCannon = new Image(),	sprNuage = new Image(),	sprBoulet = new Image(),	sprOiseauMort = new Image();sprOiseau.src = "Images/Oiseau.png";sprOiseauMort.src = "Images/OiseauMort.png";sprCoup.src = "Images/Coup.png";sprFumee.src = "Images/Fumee.png";sprCannon.src = "Images/Cannon.png";sprBoulet.src = "Images/Boulet.png";sprNuage.src = "Images/Nuage.png";// Gestion de la sourisfunction Click(){	// Le click n'est pas géré si le menu visible ou si le click est en dehors de la zone interactive	if (mainVisible || cursorX < 48 || cursorX >= width - 48 || cursorY < 32 || cursorY >= height - 96)		return;	// L'effet de fumée sur le cannon est basé sur l'angle	// Il faut faire une distinction entre la gauche et la droite car l'angle ne le fait pas	// La division de l'angle en 3 régions est basée sur l'angle:	// Math.PI / 2 -- Math.PI * 7/16	// Math.PI * 7/16 -- Math.PI * 4/16	// Math.PI * 4/16 -- ...	if ((width / 2)  < cursorX)	{		if (Angle > Math.PI * 7 / 16)			new SFX(sprFumee, 3, 24, 24, (width / 2) - 2, height - 128);		else if (Angle > Math.PI * 4 / 16)			new SFX(sprFumee, 3, 24, 24, (width / 2) + 20, height - 124);		else			new SFX(sprFumee, 3, 24, 24, (width / 2) + 34, height - 114);		new Boulet((width / 2), height - 90, Angle, true);	}	else	{		if (Angle > Math.PI * 7 / 16)			new SFX(sprFumee, 3, 24, 24, (width / 2) - 2, height - 128);		else if (Angle > Math.PI * 4 / 16)			new SFX(sprFumee, 3, 24, 24, (width / 2) - 20, height - 124);		else			new SFX(sprFumee, 3, 24, 24, (width / 2) - 34, height - 114);		new Boulet((width / 2), height - 90, Angle, false);	}}function Move(pEvent){    // Aller chercher la position de la souris sans prendre compte des barres de défilement	cursorX = pEvent.pageX - document.body.scrollLeft;	cursorY = pEvent.pageY - document.body.scrollTop;}// Gestion du boutton de visibilité du menufunction Visibilite(sender){	// Inverser la visibilité	mainVisible = !mainVisible;	if (mainVisible)	{		sender.className = "birdieLink left";		documentElement.style.cursor = 'auto';	}	else	{		sender.className = "birdieLink left activeLink";		documentElement.style.cursor = 'url(Images/Curseur.png), auto';	}	document.getElementById('mainContainer').style.cursor = documentElement.style.cursor;	document.getElementById('moulin').style.cursor = documentElement.style.cursor;}function SwitchPage(sender, page){	var elements = document.getElementsByClassName('pageLink');	for (var index = 0; index < elements.length; index++)		elements[index].className = "pageLink left";	sender.className = "pageLink left activeLink";		if (focus !== controles[page])		mainState = 'going up';	focus = controles[page];}function Oiseau(){	this.ToDispose = false;	// L'oiseau peut apparaître à n'importe qu'elle hauteur de l'écran	this.Y = Math.random() * (height - 160);	// La vitesse Y est un nombre aléatoire entre -1 et 1	this.MovY = (Math.random() - 0.5) * 2;	// La direction de l'oiseau est aléatoire	// La vitesse X est un nombre aléatoire entre 3.5 et 4.5, négatif si l'oiseau va vers la gauche	// L'oiseau apparaît sur les bords de la page	if (Math.random() < 0.5)	{		this.AnimX = 1		this.MovX = -4 + Math.random() - 0.5;		this.X = width;	}	else	{		this.AnimX = 0;		this.MovX = 4 + Math.random() - 0.5;		this.X = -24;	}		this.AnimY = 0;	this.Anim = 4;	this.GoalX = this.X;	this.GoalY = this.Y;	Objets.push(this);		Oiseau.prototype.Update = function()	{		// Modifier l'objectif de l'oiseau		this.GoalX += this.MovX;		this.GoalY += this.MovY;		// Modifier la position de manière progressive vers l'objectif		this.X = this.X * 0.9 + this.GoalX * 0.1;		this.Y = this.Y * 0.9 + this.GoalY * 0.1;		// Si l'oiseau est en dehors de l'écran ou s'il est supposé être éliminer, l'éliminer		if (this.X < -24 || this.X > width || this.Y < -16 || this.Y > height || this.ToDispose)		{			this.Dispose();			return;		}				// Faire avancer l'animation		if (this.Anim > 0)			this.Anim--;		else		{			this.Anim = 4;			this.AnimY = (this.AnimY + 1) % 4;		}		// À chaque update il y a 1% de chance que l'oiseau se fasse assigner une nouvelle vitesse et direction		if (Math.random() < 0.01)		{			this.MovY = (Math.random() - 0.5) * 2;			if (Math.random() < 0.5)			{				this.AnimX = 1				this.MovX = -4 + Math.random() - 0.5;			}			else			{				this.AnimX = 0;				this.MovX = 4 + Math.random() - 0.5;			}		}			}	Oiseau.prototype.Draw = function()	{		// Dessiner sur le canvas l'oiseau		// Sa taille est de 24x16		context.drawImage(sprOiseau, this.AnimX * 24, this.AnimY * 16, 24, 16, Math.round(this.X), Math.round(this.Y), 24, 16);	}	Oiseau.prototype.Dispose = function()	{		Objets.splice(Objets.indexOf(this), 1);		new SFX(sprOiseauMort, 5, 48, 48, this.X + 12 + this.MovX, this.Y + 10 + this.MovY);	}}function Nuage(){	// La position X est comprise entre -128 et la largeur de l'écran + 96	// Le nuage peut donc apparaître légèrement en dehors de l'écran	// La position Y est comprise entre 0 et la hauteur - 320	// Le nuage ne peut donc pas apparaître trop près du sol    this.X = Math.random() * (width + 96) - 128;    this.Y = Math.random() * (height - 320);		// La vitesse en X est statique	// La vitesse en Y est entre -0.25 et 0.25    this.MovX = vent;    this.MovY = (Math.random() - 0.5) * 0.5;	    this.Anim = 4;    this.AnimY = 0;    this.AnimDirection = 1;		Objets.push(this);	    Nuage.prototype.Update = function()    {		// Modifier la position du nuage basé sur sa vitesse		this.MovX = this.MovX * 0.9 + vent * 0.1;        this.X += this.MovX;        this.Y += this.MovY;				// Faire progresser l'animation du nuage        if (this.Anim > 0)            this.Anim--        else        {            this.Anim = 4;			// AnimY est utilisé pour déterminer l'apparation et la disparition du nuage			// À sa création, le nuage est animé en apparition et plus son AnimY est élevé, plus les chances			// qu'il se mette à disparaître sont élevées, culminant à 100% de chance après 120 changements d'anim            if (this.AnimY > Math.random() * 120)                this.AnimDirection = -1;            this.AnimY+= this.AnimDirection;			// Si son animation est négative (donc qu'il est en train de disparaître, disposer du nuage            if (this.AnimY < 0)			{                this.Dispose();				return;			}        }    }	Nuage.prototype.Draw = function()	{		// Dessiner sur le canvas le nuage        context.drawImage(sprNuage, 0, Math.min(this.AnimY, 2) * 64, 96, 64, Math.round(this.X), Math.round(this.Y), 96, 64);	}    Nuage.prototype.Dispose = function()    {		Objets.splice(Objets.indexOf(this), 1);    }}function Boulet(pX, pY, pAngle, pAngleCote){	// Créer le boulet centré sur la position donnée	// Sa taille est de 8x8, donc son centre est (4,4)    this.X = pX - 4;    this.Y = pY - 4;	// Assigner le mouvement basé sur l'angle	// La vitesse du mouvement est de 30	this.MovX = Math.cos(pAngle) * 15;	if (!pAngleCote)		this.MovX *= -1;	this.MovY = -Math.sin(pAngle) * 15;	Objets.push(this);	    Boulet.prototype.Update = function()    {		// Modifier la position du boulet        this.X += this.MovX;        this.Y += this.MovY;				// Si le boulet sort de l'écran, disposer du boulet		if (this.X < 0 || this.X > width || this.Y < 0 || this.Y > height)			this.Dispose();		var closestX, closestY, closestDistance = 1000000;		// Faire le tour des oiseaux pour voir si un a été touché		for (var index = Objets.length; index >= 0; index--)		{			if (Objets[index] instanceof Oiseau && !Objets[index].ToDispose &&												   this.X + 8 > Objets[index].X - 12 && this.X < Objets[index].X + 36 &&												   this.Y + 8 > Objets[index].Y - 8 && this.Y < Objets[index].Y + 24 )			{				Objets[index].ToDispose = true;				this.Dispose();				for (var loop = 0; loop < 0; loop++)					new Boulet(this.X, this.Y, Math.PI * (loop / 4), false);				Kills++;			}						if (Objets[index] instanceof Oiseau)			{				var tmpX = Objets[index].X + 4;				var tmpY = Objets[index].Y + 4;				var dist = Math.pow(Objets[index].X - this.X, 2) + Math.pow(Objets[index].Y - this.Y, 2);				if (dist < closestDistance)				{					closestX = Objets[index].X;					closestY = Objets[index].Y;					closestDistance = dist;				}			}		}		if (closestX !== undefined && closestY !== undefined)		{			var tmp = 15 / Math.sqrt(closestDistance);			this.MovX = this.MovX * 0.95 + (closestX - this.X) * tmp * 0.05;			this.MovY = this.MovY * 0.95 + (closestY - this.Y) * tmp * 0.05;		}    }	Boulet.prototype.Draw = function()	{		// Dessiner le boulet sur le canvas        context.drawImage(sprBoulet, this.X, this.Y);	}    Boulet.prototype.Dispose = function()    {		Objets.splice(Objets.indexOf(this), 1);		new SFX(sprCoup, 3, 24, 24, this.X + 4, this.Y + 4);    }	}function SFX(pSprite, pAnimCount, pWidth, pHeight, pX, pY){	this.Sprite = pSprite;    // La position de l'effet est ajusté pour qu'il soit centré	this.X = pX - pWidth / 2;	this.Y = pY - pHeight / 2;	this.Width = pWidth;	this.Height = pHeight;	this.Anim = 2;	this.AnimY = 0;	this.AnimCount = pAnimCount;	Objets.push(this);		SFX.prototype.Update = function()	{        // Faire progresser l'animation		if (this.Anim > 0)			this.Anim--;		else		{			this.Anim = 2;			this.AnimY++;            // Faire disparaître l'effet lorsque celui-ci est passé à travers ses images possibles			if (this.AnimY > this.AnimCount)				this.Dispose();		}		}	SFX.prototype.Draw = function()	{		context.drawImage(this.Sprite, 0, this.AnimY * this.Height, this.Width, this.Height, Math.round(this.X), Math.round(this.Y), this.Width, this.Height);	}	SFX.prototype.Dispose = function()	{		Objets.splice(Objets.indexOf(this), 1);	}}var Update = function(){	// Main movement	switch(mainState)	{		case 'going down':			if (mainHauteur <= 0)			{				if (mainHauteur + main.offsetHeight > 0)					main.style.visibility = 'visible';				mainHauteur += 48;			}			else			{				mainState = 'down';				mainHauteur = 48;			}			break;		case 'going up':			if (mainHauteur + main.offsetHeight > 0)				mainHauteur -= 48;			else				mainState = 'up';			break;		case 'down':			mainHauteur = 48;			break;		case 'up':			main.style.visibility = 'hidden';				mainState = 'going down';			switch(focus)			{				case accueil:					accueil.style.display = 'block';					apropos.style.display = 'none';					break;				case apropos:					accueil.style.display = 'none';					apropos.style.display = 'block';					break;				default:					mainState = 'up';						break;			}			mainHauteur = -main.offsetHeight;			break;	}	main.style.top =  (mainHauteur + birdieHauteur) + 'px';    // Si le menu n'est pas visible	if (!mainVisible)	{        // Faire descendre le cannon jusqu'à ce qu'il soit caché        if (cannonHauteur > 0)            cannonHauteur -=10;		if (birdieHauteur > -main.offsetHeight)			birdieHauteur -= 48;		else			birdieHauteur = -main.offsetHeight;	}    else    {        // Si le cannon est caché, le faire monter        if (cannonHauteur < 96)            cannonHauteur +=10;			if (birdieHauteur <= -48)			birdieHauteur += 48;		else			birdieHauteur = 0;	}    		    // 3% de chance qu'un oiseau apparaîsse	if (Math.random() < 0.03)		new Oiseau();    // 5% de chance qu'un nuage apparaîsse	if (Math.random() < 0.05)		new Nuage();				// Cannon's angle	var x = ((width / 2) - cursorX), y = (height - 90 - cursorY); 	Angle = Math.abs(Math.atan(y / x)), anim = 0;	if (x < 0)	{		if (Angle > Math.PI * 7 / 16)			anim = 2;		else if (Angle > Math.PI * 4 / 16)			anim = 3;		else			anim = 4;	}	else	{		if (Angle > Math.PI * 7 / 16)			anim = 2;		else if (Angle > Math.PI * 4 / 16)			anim = 1;		else			anim = 0;	}	    // Mettre à jour les objets	for (var index = Objets.length - 1; index >= 0; index--)		Objets[index].Update();			// Vent	if (Math.abs(ventObjectif - vent) < 0.1)		ventObjectif = Math.random() * 3;	vent = vent * 0.99 + ventObjectif * 0.01;	bottomLeft = (bottomLeft + vent / 7.5) % 48;	document.getElementById('bas').style.left = bottomLeft + 'px';}var Draw = function(){	context.drawImage(sprCannon, anim * 64, 0, 64, 96, Math.round(width / 2 - 32), Math.round(height - 140 + cannonHauteur), 64 ,96);	    // Mettre à jour les objets	for (var index = Objets.length - 1; index >= 0; index--)		Objets[index].Draw();			if (!mainVisible)	{        // Afficher le score		context.font = '14px Geneva';		context.fillStyle = '#000';		var texte = Kills + ' oazo(s)';		var distanceDroite = 120 + texte.length * 6.75;        context.fillText(texte, width - distanceDroite - 1, height - 110 - 1);        context.fillText(texte, width - distanceDroite - 1, height - 110 + 1);        context.fillText(texte, width - distanceDroite + 1, height - 110 + 1);        context.fillText(texte, width - distanceDroite + 1, height - 110 - 1);        context.fillText(texte, width - distanceDroite - 1, height - 110);        context.fillText(texte, width - distanceDroite + 1, height - 110);        context.fillText(texte, width - distanceDroite, height - 110 + 1);        context.fillText(texte, width - distanceDroite, height - 110 - 1);		context.fillStyle = '#fff';        context.fillText(texte, width - distanceDroite, height - 110);	}}	var GameLoop = function(){	// Détecter et assigner la taille appropriée du canvas	width = documentElement.offsetWidth;	height = documentElement.offsetHeight;	documentElement.width = width;	documentElement.height = height;		// Mettre à jour	Update();	// Dessiner	Draw();		// Mettre en dormance	gLoop = setTimeout(GameLoop, loop);}var GamesInit = function(){	var games = document.getElementsByClassName("choiceBack");	for (var index = 0; index < games.length; index++)	{		games[index].innerHTML += '<div class="chaine1"></div><div class="chaine2"></div>';	}	apropos.style.display = 'none';}// Partir la première boucleGameLoop();